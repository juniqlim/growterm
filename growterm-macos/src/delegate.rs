use std::cell::RefCell;
use std::sync::{mpsc, Arc};

use objc2::rc::Retained;
use objc2::{define_class, DefinedClass, MainThreadMarker, MainThreadOnly};
use objc2_app_kit::{NSApplication, NSApplicationDelegate};
use objc2_foundation::{NSNotification, NSObject, NSObjectProtocol};

use crate::event::AppEvent;
use crate::window::MacWindow;

type SetupFn = Box<dyn FnOnce(Arc<MacWindow>, mpsc::Receiver<AppEvent>) + 'static>;

pub(crate) struct DelegateIvars {
    setup: RefCell<Option<SetupFn>>,
}

define_class! {
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[name = "GrowAppDelegate"]
    #[ivars = DelegateIvars]
    pub(crate) struct AppDelegate;

    unsafe impl NSObjectProtocol for AppDelegate {}

    unsafe impl NSApplicationDelegate for AppDelegate {
        #[unsafe(method(applicationDidFinishLaunching:))]
        fn did_finish_launching(&self, _notification: &NSNotification) {
            let mtm = MainThreadMarker::new().unwrap();
            let app = NSApplication::sharedApplication(mtm);
            app.activate();

            // 윈도우 생성을 다음 런루프 틱으로 지연.
            // didFinishLaunching 시점에는 IMK 입력 서버의 mach port 연결이
            // 아직 완료되지 않아, 즉시 윈도우를 만들면 자소 분리가 발생함.
            let setup = self.ivars().setup.borrow_mut().take();
            if let Some(setup) = setup {
                dispatch_async_main(move || {
                    let mtm = MainThreadMarker::new().unwrap();
                    let mac_window = MacWindow::new(mtm, "growterm", 800.0, 600.0);
                    let (tx, rx) = mpsc::channel();
                    mac_window.set_sender(tx);
                    mac_window.show();

                    let mac_window = Arc::new(mac_window);
                    setup(mac_window, rx);
                });
            }
        }

        #[unsafe(method(applicationShouldTerminateAfterLastWindowClosed:))]
        fn should_terminate_after_last_window_closed(&self, _app: &NSApplication) -> bool {
            true
        }
    }
}

use std::ffi::c_void;

extern "C" {
    static _dispatch_main_q: c_void;
    fn dispatch_async_f(
        queue: *const c_void,
        context: *mut c_void,
        work: extern "C" fn(*mut c_void),
    );
}

extern "C" fn dispatch_trampoline(ctx: *mut c_void) {
    let closure: Box<Box<dyn FnOnce()>> = unsafe { Box::from_raw(ctx as *mut _) };
    closure();
}

fn dispatch_async_main<F: FnOnce() + 'static>(f: F) {
    let boxed: Box<Box<dyn FnOnce()>> = Box::new(Box::new(f));
    let ptr = Box::into_raw(boxed) as *mut c_void;
    unsafe {
        dispatch_async_f(
            &_dispatch_main_q as *const _ as *const c_void,
            ptr,
            dispatch_trampoline,
        );
    }
}

impl AppDelegate {
    pub(crate) fn new(mtm: MainThreadMarker, setup: SetupFn) -> Retained<Self> {
        let this = mtm.alloc::<Self>().set_ivars(DelegateIvars {
            setup: RefCell::new(Some(setup)),
        });
        unsafe { objc2::msg_send![super(this), init] }
    }
}

