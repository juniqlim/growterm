use growterm_types::{CellFlags, RenderCommand, Rgb};
use wgpu::util::DeviceExt;

use crate::atlas::GlyphAtlas;

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct BgVertex {
    position: [f32; 2],
    color: [f32; 3],
}

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct GlyphVertex {
    position: [f32; 2],
    tex_coords: [f32; 2],
    color: [f32; 3],
}

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct Uniforms {
    screen_size: [f32; 2],
    _padding: [f32; 2],
}

pub struct GpuDrawer {
    device: wgpu::Device,
    queue: wgpu::Queue,
    surface: wgpu::Surface<'static>,
    surface_config: wgpu::SurfaceConfiguration,
    render_format: wgpu::TextureFormat,
    bg_pipeline: wgpu::RenderPipeline,
    glyph_pipeline: wgpu::RenderPipeline,
    uniform_buffer: wgpu::Buffer,
    uniform_bind_group: wgpu::BindGroup,
    glyph_texture: wgpu::Texture,
    glyph_texture_bind_group: wgpu::BindGroup,
    glyph_texture_size: u32,
    atlas: GlyphAtlas,
    atlas_cursor_x: u32,
    atlas_cursor_y: u32,
    atlas_row_height: u32,
    glyph_regions: std::collections::HashMap<char, GlyphRegion>,
    surface_dirty: bool,
}

#[derive(Clone, Copy)]
struct GlyphRegion {
    u0: f32,
    v0: f32,
    u1: f32,
    v1: f32,
    width: u32,
    height: u32,
    offset_x: f32,
    offset_y: f32,
}

const GLYPH_TEXTURE_SIZE: u32 = 1024;

/// Tab bar rendering info passed from the app layer.
pub struct TabBarInfo {
    pub titles: Vec<String>,
    pub active_index: usize,
    pub cell_h: f32,
    pub cell_w: f32,
}

impl GpuDrawer {
    pub fn new<W>(window: std::sync::Arc<W>, width: u32, height: u32, font_size: f32) -> Self
    where
        W: raw_window_handle::HasWindowHandle
            + raw_window_handle::HasDisplayHandle
            + Send
            + Sync
            + 'static,
    {
        let instance = wgpu::Instance::new(&wgpu::InstanceDescriptor {
            backends: wgpu::Backends::all(),
            ..Default::default()
        });

        let surface = instance.create_surface(window.clone()).unwrap();

        let adapter = pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::default(),
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        }))
        .unwrap();

        let (device, queue) = pollster::block_on(adapter.request_device(
            &wgpu::DeviceDescriptor {
                label: Some("growterm device"),
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::default(),
                ..Default::default()
            },
            None,
        ))
        .unwrap();
        let surface_caps = surface.get_capabilities(&adapter);
        let surface_format = surface_caps.formats[0];

        // Use non-sRGB view to avoid double gamma encoding of ANSI colors
        let render_format = match surface_format {
            wgpu::TextureFormat::Bgra8UnormSrgb => wgpu::TextureFormat::Bgra8Unorm,
            wgpu::TextureFormat::Rgba8UnormSrgb => wgpu::TextureFormat::Rgba8Unorm,
            other => other,
        };
        let view_formats = if render_format != surface_format {
            vec![render_format]
        } else {
            vec![]
        };

        let surface_config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format: surface_format,
            width: width.max(1),
            height: height.max(1),
            present_mode: wgpu::PresentMode::Fifo,
            alpha_mode: surface_caps.alpha_modes[0],
            view_formats,
            desired_maximum_frame_latency: 2,
        };
        surface.configure(&device, &surface_config);

        // Uniform buffer
        let uniforms = Uniforms {
            screen_size: [width as f32, height as f32],
            _padding: [0.0; 2],
        };
        let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("uniforms"),
            contents: bytemuck::bytes_of(&uniforms),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let uniform_bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some("uniform_bgl"),
                entries: &[wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                }],
            });

        let uniform_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("uniform_bg"),
            layout: &uniform_bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: uniform_buffer.as_entire_binding(),
            }],
        });

        // Glyph texture + bind group
        let glyph_texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("glyph_atlas"),
            size: wgpu::Extent3d {
                width: GLYPH_TEXTURE_SIZE,
                height: GLYPH_TEXTURE_SIZE,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::R8Unorm,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });

        let glyph_texture_view = glyph_texture.create_view(&Default::default());
        let glyph_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            mag_filter: wgpu::FilterMode::Nearest,
            min_filter: wgpu::FilterMode::Nearest,
            ..Default::default()
        });

        let glyph_texture_bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some("glyph_bgl"),
                entries: &[
                    wgpu::BindGroupLayoutEntry {
                        binding: 0,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Texture {
                            sample_type: wgpu::TextureSampleType::Float { filterable: true },
                            view_dimension: wgpu::TextureViewDimension::D2,
                            multisampled: false,
                        },
                        count: None,
                    },
                    wgpu::BindGroupLayoutEntry {
                        binding: 1,
                        visibility: wgpu::ShaderStages::FRAGMENT,
                        ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                        count: None,
                    },
                ],
            });

        let glyph_texture_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("glyph_bg"),
            layout: &glyph_texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::TextureView(&glyph_texture_view),
                },
                wgpu::BindGroupEntry {
                    binding: 1,
                    resource: wgpu::BindingResource::Sampler(&glyph_sampler),
                },
            ],
        });

        // Background pipeline
        let bg_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("bg_shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("shaders/bg.wgsl").into()),
        });

        let bg_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: Some("bg_pipeline_layout"),
            bind_group_layouts: &[&uniform_bind_group_layout],
            push_constant_ranges: &[],
        });

        let bg_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("bg_pipeline"),
            layout: Some(&bg_pipeline_layout),
            vertex: wgpu::VertexState {
                module: &bg_shader,
                entry_point: Some("vs_main"),
                buffers: &[wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<BgVertex>() as u64,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &wgpu::vertex_attr_array![0 => Float32x2, 1 => Float32x3],
                }],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &bg_shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: render_format,
                    blend: None,
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });

        // Glyph pipeline
        let glyph_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("glyph_shader"),
            source: wgpu::ShaderSource::Wgsl(include_str!("shaders/glyph.wgsl").into()),
        });

        let glyph_pipeline_layout =
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("glyph_pipeline_layout"),
                bind_group_layouts: &[&uniform_bind_group_layout, &glyph_texture_bind_group_layout],
                push_constant_ranges: &[],
            });

        let glyph_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("glyph_pipeline"),
            layout: Some(&glyph_pipeline_layout),
            vertex: wgpu::VertexState {
                module: &glyph_shader,
                entry_point: Some("vs_main"),
                buffers: &[wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<GlyphVertex>() as u64,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &wgpu::vertex_attr_array![0 => Float32x2, 1 => Float32x2, 2 => Float32x3],
                }],
                compilation_options: Default::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &glyph_shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState {
                    format: render_format,
                    blend: Some(wgpu::BlendState {
                        color: wgpu::BlendComponent {
                            src_factor: wgpu::BlendFactor::SrcAlpha,
                            dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
                            operation: wgpu::BlendOperation::Add,
                        },
                        alpha: wgpu::BlendComponent::OVER,
                    }),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: Default::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
            cache: None,
        });

        let atlas = GlyphAtlas::new(font_size);

        Self {
            device,
            queue,
            surface,
            surface_config,
            render_format,
            bg_pipeline,
            glyph_pipeline,
            uniform_buffer,
            uniform_bind_group,
            glyph_texture,
            glyph_texture_bind_group,
            glyph_texture_size: GLYPH_TEXTURE_SIZE,
            atlas,
            atlas_cursor_x: 0,
            atlas_cursor_y: 0,
            atlas_row_height: 0,
            glyph_regions: std::collections::HashMap::new(),
            surface_dirty: false,
        }
    }

    pub fn set_font_size(&mut self, size: f32) {
        self.atlas.set_size(size);
        self.glyph_regions.clear();
        self.atlas_cursor_x = 0;
        self.atlas_cursor_y = 0;
        self.atlas_row_height = 0;
    }

    pub fn resize(&mut self, width: u32, height: u32) {
        if width == 0 || height == 0 {
            return;
        }
        if self.surface_config.width == width && self.surface_config.height == height {
            return;
        }
        self.surface_config.width = width;
        self.surface_config.height = height;
        self.surface_dirty = true;
    }

    pub fn cell_size(&self) -> (f32, f32) {
        self.atlas.cell_size()
    }

    pub fn draw(
        &mut self,
        commands: &[RenderCommand],
        scrollbar: Option<(f32, f32)>,
        tab_bar: Option<&TabBarInfo>,
    ) {
        if self.surface_dirty {
            self.surface_dirty = false;
            self.surface.configure(&self.device, &self.surface_config);
            let uniforms = Uniforms {
                screen_size: [
                    self.surface_config.width as f32,
                    self.surface_config.height as f32,
                ],
                _padding: [0.0; 2],
            };
            self.queue
                .write_buffer(&self.uniform_buffer, 0, bytemuck::bytes_of(&uniforms));
        }
        let output = match self.surface.get_current_texture() {
            Ok(t) => t,
            Err(_) => return,
        };
        let view = output.texture.create_view(&wgpu::TextureViewDescriptor {
            format: Some(self.render_format),
            ..Default::default()
        });

        let (cell_w, cell_h) = self.atlas.cell_size();

        // Build bg vertices
        let mut bg_vertices: Vec<BgVertex> = Vec::new();
        for cmd in commands {
            let x = cmd.col as f32 * cell_w;
            let y = cmd.row as f32 * cell_h;
            let w = if cmd.flags.contains(CellFlags::WIDE_CHAR) {
                cell_w * 2.0
            } else {
                cell_w
            };
            let color = rgb_to_f32(cmd.bg);

            bg_vertices.push(BgVertex {
                position: [x, y],
                color,
            });
            bg_vertices.push(BgVertex {
                position: [x + w, y],
                color,
            });
            bg_vertices.push(BgVertex {
                position: [x, y + cell_h],
                color,
            });
            bg_vertices.push(BgVertex {
                position: [x + w, y],
                color,
            });
            bg_vertices.push(BgVertex {
                position: [x + w, y + cell_h],
                color,
            });
            bg_vertices.push(BgVertex {
                position: [x, y + cell_h],
                color,
            });

            // Underline: thin rect at cell bottom using fg color
            if cmd.flags.contains(CellFlags::UNDERLINE) {
                let underline_h = (cell_h * 0.07).max(1.0);
                let underline_y = y + cell_h - underline_h;
                let fg_color = rgb_to_f32(cmd.fg);
                push_bg_rect(&mut bg_vertices, x, underline_y, w, underline_h, fg_color);
            }
        }

        // Build glyph vertices
        let mut glyph_vertices: Vec<GlyphVertex> = Vec::new();

        // Helper: push a fg-colored rectangle into bg_vertices
        let push_rect =
            |bg_verts: &mut Vec<BgVertex>, x: f32, y: f32, w: f32, h: f32, color: [f32; 3]| {
                push_bg_rect(bg_verts, x, y, w, h, color);
            };

        for cmd in commands {
            if cmd.character == ' ' {
                continue;
            }
            if cmd.flags.contains(CellFlags::HIDDEN) {
                continue;
            }

            // Block elements (U+2580..U+259F, excluding shades U+2591-U+2593)
            let ch = cmd.character;
            if ch >= '\u{2580}' && ch <= '\u{259F}' && !(ch >= '\u{2591}' && ch <= '\u{2593}') {
                let cx = cmd.col as f32 * cell_w;
                let cy = cmd.row as f32 * cell_h;
                let fg = rgb_to_f32(cmd.fg);
                if push_block_element_rects(&mut bg_vertices, ch, cx, cy, cell_w, cell_h, fg) {
                    continue;
                }
            }

            // Box drawing characters (U+2500..U+257F)
            if ch >= '\u{2500}' && ch <= '\u{257F}' {
                if let Some(segs) = box_drawing_segments(ch) {
                    let cx = cmd.col as f32 * cell_w;
                    let cy = cmd.row as f32 * cell_h;
                    let fg = rgb_to_f32(cmd.fg);
                    let light_h = 1.0_f32;
                    let heavy_h = (cell_h / 8.0).ceil().max(2.0);
                    let light_w = 1.0_f32;
                    let heavy_w = (cell_w / 8.0).ceil().max(2.0);
                    let mid_x = (cell_w / 2.0).floor();
                    let mid_y = (cell_h / 2.0).floor();

                    // Horizontal segment
                    if segs.h_weight != LineWeight::None && segs.h_weight != LineWeight::Double {
                        let th = if segs.h_weight == LineWeight::Heavy {
                            heavy_h
                        } else {
                            light_h
                        };
                        let x0 = if segs.left {
                            0.0
                        } else {
                            mid_x - (th / 2.0).floor()
                        };
                        let x1 = if segs.right {
                            cell_w
                        } else {
                            mid_x + (th / 2.0).ceil()
                        };
                        push_rect(
                            &mut bg_vertices,
                            cx + x0,
                            cy + mid_y - (th / 2.0).floor(),
                            x1 - x0,
                            th,
                            fg,
                        );
                    }
                    // Vertical segment
                    if segs.v_weight != LineWeight::None && segs.v_weight != LineWeight::Double {
                        let tw = if segs.v_weight == LineWeight::Heavy {
                            heavy_w
                        } else {
                            light_w
                        };
                        let y0 = if segs.up {
                            0.0
                        } else {
                            mid_y - (tw / 2.0).floor()
                        };
                        let y1 = if segs.down {
                            cell_h
                        } else {
                            mid_y + (tw / 2.0).ceil()
                        };
                        push_rect(
                            &mut bg_vertices,
                            cx + mid_x - (tw / 2.0).floor(),
                            cy + y0,
                            tw,
                            y1 - y0,
                            fg,
                        );
                    }
                    // Double horizontal
                    if segs.h_weight == LineWeight::Double {
                        let gap = (cell_h / 6.0).ceil();
                        let th = light_h;
                        let x0 = if segs.left { 0.0 } else { mid_x };
                        let x1 = if segs.right { cell_w } else { mid_x + light_w };
                        push_rect(
                            &mut bg_vertices,
                            cx + x0,
                            cy + mid_y - gap - th / 2.0,
                            x1 - x0,
                            th,
                            fg,
                        );
                        push_rect(
                            &mut bg_vertices,
                            cx + x0,
                            cy + mid_y + gap - th / 2.0,
                            x1 - x0,
                            th,
                            fg,
                        );
                    }
                    // Double vertical
                    if segs.v_weight == LineWeight::Double {
                        let gap = (cell_w / 6.0).ceil();
                        let tw = light_w;
                        let y0 = if segs.up { 0.0 } else { mid_y };
                        let y1 = if segs.down { cell_h } else { mid_y + light_h };
                        push_rect(
                            &mut bg_vertices,
                            cx + mid_x - gap - tw / 2.0,
                            cy + y0,
                            tw,
                            y1 - y0,
                            fg,
                        );
                        push_rect(
                            &mut bg_vertices,
                            cx + mid_x + gap - tw / 2.0,
                            cy + y0,
                            tw,
                            y1 - y0,
                            fg,
                        );
                    }
                    continue;
                }
            }

            let region = self.ensure_glyph_in_atlas(cmd.character);
            if region.width == 0 || region.height == 0 {
                continue;
            }

            let cell_x = cmd.col as f32 * cell_w;
            let cell_y = cmd.row as f32 * cell_h;

            // Position glyph within cell
            let baseline_y = cell_y + cell_h * 0.8; // approximate baseline
            let gx = cell_x + region.offset_x;
            let gy = baseline_y - region.offset_y - region.height as f32;
            let gw = region.width as f32;
            let gh = region.height as f32;

            let color = rgb_to_f32(cmd.fg);

            glyph_vertices.push(GlyphVertex {
                position: [gx, gy],
                tex_coords: [region.u0, region.v0],
                color,
            });
            glyph_vertices.push(GlyphVertex {
                position: [gx + gw, gy],
                tex_coords: [region.u1, region.v0],
                color,
            });
            glyph_vertices.push(GlyphVertex {
                position: [gx, gy + gh],
                tex_coords: [region.u0, region.v1],
                color,
            });
            glyph_vertices.push(GlyphVertex {
                position: [gx + gw, gy],
                tex_coords: [region.u1, region.v0],
                color,
            });
            glyph_vertices.push(GlyphVertex {
                position: [gx + gw, gy + gh],
                tex_coords: [region.u1, region.v1],
                color,
            });
            glyph_vertices.push(GlyphVertex {
                position: [gx, gy + gh],
                tex_coords: [region.u0, region.v1],
                color,
            });
        }

        // Scrollbar
        if let Some((thumb_top_ratio, thumb_height_ratio)) = scrollbar {
            let screen_w = self.surface_config.width as f32;
            let screen_h = self.surface_config.height as f32;
            let bar_w = 6.0_f32;
            let x0 = screen_w - bar_w;
            let y0 = thumb_top_ratio * screen_h;
            let h = thumb_height_ratio * screen_h;
            let color = [0.5, 0.5, 0.5];
            push_rect(&mut bg_vertices, x0, y0, bar_w, h, color);
        }

        // Tab bar
        if let Some(tab_info) = tab_bar {
            let bar_h = tab_info.cell_h;
            let screen_w = self.surface_config.width as f32;
            let bar_bg: [f32; 3] = [0.15, 0.15, 0.15];
            let active_bg: [f32; 3] = [0.3, 0.3, 0.3];

            push_rect(&mut bg_vertices, 0.0, 0.0, screen_w, bar_h, bar_bg);

            let tab_count = tab_info.titles.len().max(1) as f32;
            let tab_w = screen_w / tab_count;
            let mut x = 0.0_f32;
            for (i, title) in tab_info.titles.iter().enumerate() {
                if i == tab_info.active_index {
                    push_rect(&mut bg_vertices, x, 0.0, tab_w, bar_h, active_bg);
                }

                let text_w = title.chars().count() as f32 * tab_info.cell_w;
                let mut cx = x + (tab_w - text_w) / 2.0;
                for ch in title.chars() {
                    if ch == ' ' {
                        cx += tab_info.cell_w;
                        continue;
                    }
                    let region = self.ensure_glyph_in_atlas(ch);
                    if region.width > 0 && region.height > 0 {
                        let baseline_y = bar_h * 0.8;
                        let gx = cx + region.offset_x;
                        let gy = baseline_y - region.offset_y - region.height as f32;
                        let gw = region.width as f32;
                        let gh = region.height as f32;
                        let color: [f32; 3] = if i == tab_info.active_index {
                            [1.0, 1.0, 1.0]
                        } else {
                            [0.6, 0.6, 0.6]
                        };
                        glyph_vertices.push(GlyphVertex {
                            position: [gx, gy],
                            tex_coords: [region.u0, region.v0],
                            color,
                        });
                        glyph_vertices.push(GlyphVertex {
                            position: [gx + gw, gy],
                            tex_coords: [region.u1, region.v0],
                            color,
                        });
                        glyph_vertices.push(GlyphVertex {
                            position: [gx, gy + gh],
                            tex_coords: [region.u0, region.v1],
                            color,
                        });
                        glyph_vertices.push(GlyphVertex {
                            position: [gx + gw, gy],
                            tex_coords: [region.u1, region.v0],
                            color,
                        });
                        glyph_vertices.push(GlyphVertex {
                            position: [gx + gw, gy + gh],
                            tex_coords: [region.u1, region.v1],
                            color,
                        });
                        glyph_vertices.push(GlyphVertex {
                            position: [gx, gy + gh],
                            tex_coords: [region.u0, region.v1],
                            color,
                        });
                    }
                    cx += tab_info.cell_w;
                }

                x += tab_w;
            }
        }

        let bg_buffer = self
            .device
            .create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some("bg_vb"),
                contents: bytemuck::cast_slice(&bg_vertices),
                usage: wgpu::BufferUsages::VERTEX,
            });

        let glyph_buffer = self
            .device
            .create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some("glyph_vb"),
                contents: bytemuck::cast_slice(&glyph_vertices),
                usage: wgpu::BufferUsages::VERTEX,
            });

        let mut encoder = self
            .device
            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                label: Some("render_encoder"),
            });

        {
            let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("render_pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color {
                            r: 0.0,
                            g: 0.0,
                            b: 0.0,
                            a: 1.0,
                        }),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: None,
                ..Default::default()
            });

            // Pass 1: backgrounds
            if !bg_vertices.is_empty() {
                pass.set_pipeline(&self.bg_pipeline);
                pass.set_bind_group(0, &self.uniform_bind_group, &[]);
                pass.set_vertex_buffer(0, bg_buffer.slice(..));
                pass.draw(0..bg_vertices.len() as u32, 0..1);
            }

            // Pass 2: glyphs
            if !glyph_vertices.is_empty() {
                pass.set_pipeline(&self.glyph_pipeline);
                pass.set_bind_group(0, &self.uniform_bind_group, &[]);
                pass.set_bind_group(1, &self.glyph_texture_bind_group, &[]);
                pass.set_vertex_buffer(0, glyph_buffer.slice(..));
                pass.draw(0..glyph_vertices.len() as u32, 0..1);
            }
        }

        self.queue.submit(std::iter::once(encoder.finish()));
        output.present();
    }

    fn ensure_glyph_in_atlas(&mut self, c: char) -> GlyphRegion {
        if let Some(&region) = self.glyph_regions.get(&c) {
            return region;
        }

        let glyph = self.atlas.get_or_insert(c);
        let w = glyph.width;
        let h = glyph.height;

        if w == 0 || h == 0 {
            let region = GlyphRegion {
                u0: 0.0,
                v0: 0.0,
                u1: 0.0,
                v1: 0.0,
                width: 0,
                height: 0,
                offset_x: 0.0,
                offset_y: 0.0,
            };
            self.glyph_regions.insert(c, region);
            return region;
        }

        // Advance cursor, wrap to next row if needed
        if self.atlas_cursor_x + w > self.glyph_texture_size {
            self.atlas_cursor_x = 0;
            self.atlas_cursor_y += self.atlas_row_height;
            self.atlas_row_height = 0;
        }

        let x = self.atlas_cursor_x;
        let y = self.atlas_cursor_y;
        self.atlas_cursor_x += w;
        self.atlas_row_height = self.atlas_row_height.max(h);

        // Upload to GPU texture
        self.queue.write_texture(
            wgpu::TexelCopyTextureInfo {
                texture: &self.glyph_texture,
                mip_level: 0,
                origin: wgpu::Origin3d { x, y, z: 0 },
                aspect: wgpu::TextureAspect::All,
            },
            &glyph.bitmap,
            wgpu::TexelCopyBufferLayout {
                offset: 0,
                bytes_per_row: Some(w),
                rows_per_image: None,
            },
            wgpu::Extent3d {
                width: w,
                height: h,
                depth_or_array_layers: 1,
            },
        );

        let ts = self.glyph_texture_size as f32;
        let region = GlyphRegion {
            u0: x as f32 / ts,
            v0: y as f32 / ts,
            u1: (x + w) as f32 / ts,
            v1: (y + h) as f32 / ts,
            width: w,
            height: h,
            offset_x: glyph.offset_x,
            offset_y: glyph.offset_y,
        };
        self.glyph_regions.insert(c, region);
        region
    }
}

fn rgb_to_f32(rgb: Rgb) -> [f32; 3] {
    [
        rgb.r as f32 / 255.0,
        rgb.g as f32 / 255.0,
        rgb.b as f32 / 255.0,
    ]
}

fn push_bg_rect(bg_verts: &mut Vec<BgVertex>, x: f32, y: f32, w: f32, h: f32, color: [f32; 3]) {
    bg_verts.push(BgVertex {
        position: [x, y],
        color,
    });
    bg_verts.push(BgVertex {
        position: [x + w, y],
        color,
    });
    bg_verts.push(BgVertex {
        position: [x, y + h],
        color,
    });
    bg_verts.push(BgVertex {
        position: [x + w, y],
        color,
    });
    bg_verts.push(BgVertex {
        position: [x + w, y + h],
        color,
    });
    bg_verts.push(BgVertex {
        position: [x, y + h],
        color,
    });
}

fn push_block_element_rects(
    bg_verts: &mut Vec<BgVertex>,
    ch: char,
    cx: f32,
    cy: f32,
    cell_w: f32,
    cell_h: f32,
    fg: [f32; 3],
) -> bool {
    let hw = cell_w / 2.0;
    let hh = cell_h / 2.0;
    match ch {
        '\u{2588}' => push_bg_rect(bg_verts, cx, cy, cell_w, cell_h, fg), // █
        '\u{2580}' => push_bg_rect(bg_verts, cx, cy, cell_w, hh, fg),     // ▀
        '\u{2584}' => push_bg_rect(bg_verts, cx, cy + hh, cell_w, hh, fg), // ▄
        '\u{258C}' => push_bg_rect(bg_verts, cx, cy, hw, cell_h, fg),     // ▌
        '\u{2590}' => push_bg_rect(bg_verts, cx + hw, cy, hw, cell_h, fg), // ▐
        '\u{259B}' => {
            // ▛ upper half + lower-left
            push_bg_rect(bg_verts, cx, cy, cell_w, hh, fg);
            push_bg_rect(bg_verts, cx, cy + hh, hw, hh, fg);
        }
        '\u{259C}' => {
            // ▜ upper half + lower-right
            push_bg_rect(bg_verts, cx, cy, cell_w, hh, fg);
            push_bg_rect(bg_verts, cx + hw, cy + hh, hw, hh, fg);
        }
        '\u{2599}' => {
            // ▙ lower half + upper-left
            push_bg_rect(bg_verts, cx, cy, hw, hh, fg);
            push_bg_rect(bg_verts, cx, cy + hh, cell_w, hh, fg);
        }
        '\u{259F}' => {
            // ▟ lower half + upper-right
            push_bg_rect(bg_verts, cx + hw, cy, hw, hh, fg);
            push_bg_rect(bg_verts, cx, cy + hh, cell_w, hh, fg);
        }
        '\u{2598}' => push_bg_rect(bg_verts, cx, cy, hw, hh, fg), // ▘
        '\u{259D}' => push_bg_rect(bg_verts, cx + hw, cy, hw, hh, fg), // ▝
        '\u{2596}' => push_bg_rect(bg_verts, cx, cy + hh, hw, hh, fg), // ▖
        '\u{2597}' => push_bg_rect(bg_verts, cx + hw, cy + hh, hw, hh, fg), // ▗
        '\u{259A}' => {
            // ▚ upper-left + lower-right
            push_bg_rect(bg_verts, cx, cy, hw, hh, fg);
            push_bg_rect(bg_verts, cx + hw, cy + hh, hw, hh, fg);
        }
        '\u{259E}' => {
            // ▞ upper-right + lower-left
            push_bg_rect(bg_verts, cx + hw, cy, hw, hh, fg);
            push_bg_rect(bg_verts, cx, cy + hh, hw, hh, fg);
        }
        _ => return false,
    }
    true
}

#[derive(Clone, Copy, PartialEq)]
enum LineWeight {
    None,
    Light,
    Heavy,
    Double,
}

struct BoxSegments {
    left: bool,
    right: bool,
    up: bool,
    down: bool,
    h_weight: LineWeight,
    v_weight: LineWeight,
}

fn box_drawing_segments(ch: char) -> Option<BoxSegments> {
    use LineWeight::*;
    let s = |left, right, up, down, h: LineWeight, v: LineWeight| {
        Some(BoxSegments {
            left,
            right,
            up,
            down,
            h_weight: h,
            v_weight: v,
        })
    };
    match ch {
        // Light lines
        '\u{2500}' => s(true, true, false, false, Light, None), // ─
        '\u{2502}' => s(false, false, true, true, None, Light), // │
        '\u{250C}' => s(false, true, false, true, Light, Light), // ┌
        '\u{2510}' => s(true, false, false, true, Light, Light), // ┐
        '\u{2514}' => s(false, true, true, false, Light, Light), // └
        '\u{2518}' => s(true, false, true, false, Light, Light), // ┘
        '\u{251C}' => s(false, true, true, true, Light, Light), // ├
        '\u{2524}' => s(true, false, true, true, Light, Light), // ┤
        '\u{252C}' => s(true, true, false, true, Light, Light), // ┬
        '\u{2534}' => s(true, true, true, false, Light, Light), // ┴
        '\u{253C}' => s(true, true, true, true, Light, Light),  // ┼
        // Heavy lines
        '\u{2501}' => s(true, true, false, false, Heavy, None), // ━
        '\u{2503}' => s(false, false, true, true, None, Heavy), // ┃
        '\u{250F}' => s(false, true, false, true, Heavy, Heavy), // ┏
        '\u{2513}' => s(true, false, false, true, Heavy, Heavy), // ┓
        '\u{2517}' => s(false, true, true, false, Heavy, Heavy), // ┗
        '\u{251B}' => s(true, false, true, false, Heavy, Heavy), // ┛
        '\u{2523}' => s(false, true, true, true, Heavy, Heavy), // ┣
        '\u{252B}' => s(true, false, true, true, Heavy, Heavy), // ┫
        '\u{2533}' => s(true, true, false, true, Heavy, Heavy), // ┳
        '\u{253B}' => s(true, true, true, false, Heavy, Heavy), // ┻
        '\u{254B}' => s(true, true, true, true, Heavy, Heavy),  // ╋
        // Double lines
        '\u{2550}' => s(true, true, false, false, Double, None), // ═
        '\u{2551}' => s(false, false, true, true, None, Double), // ║
        '\u{2554}' => s(false, true, false, true, Double, Double), // ╔
        '\u{2557}' => s(true, false, false, true, Double, Double), // ╗
        '\u{255A}' => s(false, true, true, false, Double, Double), // ╚
        '\u{255D}' => s(true, false, true, false, Double, Double), // ╝
        '\u{2560}' => s(false, true, true, true, Double, Double), // ╠
        '\u{2563}' => s(true, false, true, true, Double, Double), // ╣
        '\u{2566}' => s(true, true, false, true, Double, Double), // ╦
        '\u{2569}' => s(true, true, true, false, Double, Double), // ╩
        '\u{256C}' => s(true, true, true, true, Double, Double), // ╬
        // Rounded corners (light)
        '\u{256D}' => s(false, true, false, true, Light, Light), // ╭
        '\u{256E}' => s(true, false, false, true, Light, Light), // ╮
        '\u{256F}' => s(true, false, true, false, Light, Light), // ╯
        '\u{2570}' => s(false, true, true, false, Light, Light), // ╰
        _ => Option::None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn supported_block_element_uses_rect_path() {
        let mut vertices = Vec::new();
        let handled = push_block_element_rects(
            &mut vertices,
            '\u{2588}', // █
            0.0,
            0.0,
            10.0,
            20.0,
            [1.0, 1.0, 1.0],
        );
        assert!(handled);
        assert_eq!(vertices.len(), 6);
    }

    #[test]
    fn unsupported_block_element_falls_back_to_glyph_path() {
        let mut vertices = Vec::new();
        let handled = push_block_element_rects(
            &mut vertices,
            '\u{2585}', // ▅ (currently not in rect mapping)
            0.0,
            0.0,
            10.0,
            20.0,
            [1.0, 1.0, 1.0],
        );
        assert!(!handled);
        assert!(vertices.is_empty());
    }
}
